## 1. Web Cache Deception and Web Cache Poisoning?

Перший допомагаэ получити дані користувача другий заставити косриутвача прочитати наші данні.

## 2. Два параметра для проведення Session Fixation

Наприклад ми можемо відправити https://example.com/login;jsessionid=abcd1234 жертві важно чтоб jsessionid записався
сессію(xss наприклад) і друге чтоб не змінився

## 3. Base64 and Base64URL encoding

Другий варінт більш підходе для урл, томущо замніє  "-"  на  "+", і a "_"  на "/"

## 4. П'ять (або більше) типів Cross-Site Scripting (XSS):

1. **Stored XSS**: шкідливий скрипт зберігається на сервері (наприклад, у базі даних) і виконується при відвідуванні
   сторінки іншими користувачами.
    - **Приклад**: скрипт вставляється в коментар на форумі.

2. **Reflected XSS**: скрипт передається через URL або запит і відображається на сторінці без збереження.
    - **Приклад**: передача скрипта через параметр в URL (`https://example.com/?search=<script>alert(1)</script>`).

3. **DOM-Based XSS**: уразливість виникає через маніпуляції з об'єктною моделлю документа (DOM) на стороні клієнта.
    - **Приклад**: JavaScript на клієнтській стороні бере дані з URL і додає їх у HTML без фільтрації.

4. **Self XSS**: користувач сам виконує скрипт у консолі браузера, зазвичай через соціальну інженерію.
    - **Приклад**: атака через переконання жертви ввести скрипт у консолі для отримання «бонусу».

5. **Blind XSS**: атакуючий не бачить результат виконання скрипта, і він активується у сторонній системі, наприклад, в
   панелі адміністратора.
    - **Приклад**: скрипт надсилається через форму зворотного зв'язку і виконується, коли адміністратор переглядає
      повідомлення.

6. **Mutated XSS (або M-XSS)**: уразливість виникає при зміні браузером вихідного шкідливого коду під час рендерингу, що
   призводить до несподіваного виконання.
    - **Приклад**: браузер змінює вихідний код, і скрипт спрацьовує, хоча він був змінений і не відразу помітний.

## 5. Як працює Boolean *Error* Inferential (Blind) SQL Injection

**Boolean Error Inferential SQL Injection**, або **Blind SQL Injection** за допомогою булевих умов, використовує логічні
вирази для ін'єкції, коли прямої відповіді від бази даних немає, але можна визначити стан (істина/хиба) за поведінкою
застосунку.

1. **Логічна умова в запиті**: атакуючий вставляє в запит булевий вираз, який завжди буде або істинним, або хибним. Це
   дозволяє перевіряти, як застосунок поводиться за різних умов.

2. **Аналіз поведінки відповіді**: якщо доданий вираз істинний, застосунок може повертати звичайну сторінку, а якщо
   хибний — інший тип відповіді (наприклад, помилка або порожня сторінка). Це дозволяє з’ясувати значення конкретних
   даних з бази.

   **Приклад POC**:
   Припустимо, запит `https://example.com/product?id=1` повертає сторінку з продуктом. Якщо атакуючий додає ін'єкцію:

https://example.com/product?id=1 AND 1=1

і сторінка завантажується нормально, значить, ін'єкція працює. Далі він змінює запит на:

https://example.com/product?id=1 AND 1=2 Якщо сторінка не завантажується або з'являється інша відповідь, це підтверджує
можливість використовувати Boolean Error Inferential Injection для витягування даних.

## 6. Що таке Same-Origin Policy (SOP) і як він працює?

**Same-Origin Policy (SOP)** — це політика безпеки браузера, яка обмежує взаємодію між ресурсами, що завантажуються з
різних джерел. Ця політика захищає від несанкціонованого доступу до даних, дозволяючи взаємодію тільки між ресурсами, що
мають однакове джерело.

1. **Що означає "однакове джерело"**: два URL вважаються такими, що мають однакове джерело, якщо у них збігаються:
    - **Протокол** (наприклад, `http` або `https`),
    - **Домен** (наприклад, `example.com`),
    - **Порт** (наприклад, `:80` для HTTP або `:443` для HTTPS).

## 7. Як працює варіант TE.TE у HTTP Request Smuggling

**TE.TE HTTP Request Smuggling** — це техніка, яка використовує різночитання в обробці заголовків `Transfer-Encoding`
і `Content-Length` між різними проксі-серверами або серверами для ін'єкції запиту. Цей варіант працює, коли сервери
обробляють заголовки `Transfer-Encoding: chunked` по-різному.

1. **Принцип роботи**: атака TE.TE експлуатує невідповідність в обробці заголовка `Transfer-Encoding: chunked` у першому
   сервері і невідповідність, коли другий сервер використовує `Content-Length` для визначення меж запиту.

2. **Процес атаки**:
    - Атакуючий надсилає запит з заголовком `Transfer-Encoding: chunked` до проксі-сервера.
    - Перший сервер обробляє цей заголовок і інтерпретує запит як "chunked", але передає його далі до іншого сервера,
      який ігнорує `Transfer-Encoding` і розглядає тіло запиту на основі `Content-Length`.
    - Це створює можливість розділити запит, ін’єктуючи додаткові HTTP-запити, які будуть оброблені другим сервером як
      окремі запити.

## 8. Що таке DOM Clobbering і як його можна використати для обходу HTML-санацізаторів, що призводить до XSS?

**DOM Clobbering** — це техніка, що використовує властивості DOM для маніпуляції HTML-структурою, де змінюються або
перезаписуються певні елементи. Це може створити уразливості, особливо коли HTML-санацізатори пропускають деякі елементи
або атрибути, дозволяючи обхід і запуск шкідливого коду.

1. **Як це працює**: браузери автоматично прив’язують певні HTML-елементи до глобальних JavaScript-змінних на сторінці.
   Наприклад, елемент з атрибутом `name="form"` створює змінну `form`, доступну через `window.form`.

2. **Обхід HTML-санацізаторів**: оскільки деякі санацізатори можуть не перевіряти наявність атрибуту `name` або `id`, це
   дозволяє атакуючому створити елемент з маніпуляціями в DOM і перенаправити критичний функціонал (наприклад, замінити
   форму або скрипт).

3. **Приклад POC**:
   Якщо є код, що використовує `document.forms[0].submit()`, атакуючий може впровадити наступний код:
   ```html
   <meta name="form" content="javascript:alert(1)">
   <form id="form" name="form"></form>

## 9. Як HTTP Parameter Pollution може обійти Web Application Firewall (WAF)

**HTTP Parameter Pollution (HPP)** — це техніка, яка використовує дублювання параметрів в одному HTTP-запиті, щоб обійти
правила валідації або захисту, застосовувані Web Application Firewall (WAF). WAF може обробляти або фільтрувати тільки
перший параметр, ігноруючи інші, що дозволяє обходити правила безпеки.

1. **Принцип роботи HPP**: атакуючий додає кілька однакових параметрів в URL або в тілі запиту, де WAF обробляє тільки
   перший параметр або не налаштований на виявлення такої конструкції.

2. **Метод обходу**:
    - Якщо WAF дозволяє лише певні значення параметрів, але не враховує дублювання, атакуючий може додати шкідливий
      параметр як другий.
    - Наприклад, якщо параметр `id` фільтрується за певним значенням, то запит `id=123&id=<script>alert(1)</script>`
      може обійти WAF, так як WAF дозволяє перший параметр, а додатковий ігнорує.

3. **Приклад POC**:
   Якщо є URL з параметром `id`, який захищений WAF:
   https://example.com/search?id=123

Атакуючий може дублювати параметр:
https://example.com/search?id=123&id=<script>alert(1)</script>

Якщо сервер обробляє другий параметр `id`, тоді як WAF дозволяє лише перший, це може призвести до виконання шкідливого
коду.

**HTTP Parameter Pollution** допомагає обійти WAF, експлуатуючи обробку дубльованих параметрів

## 10. Що таке IDOR і чим його усунення відрізняється від інших уразливостей контролю доступу

**IDOR (Insecure Direct Object Reference)** — це уразливість, коли користувач може отримати доступ до об’єктів (файлів,
записів у базі даних тощо), змінюючи параметри, такі як `id`, без відповідної авторизації. Це дозволяє отримати доступ
до об’єктів інших користувачів або критичних даних, якщо система не перевіряє, чи належить об'єкт поточному
користувачеві.

1. **Принцип роботи**: користувач може змінити параметр `id` в URL або запиті, наприклад:

https://example.com/user/profile?id=100
замінивши значення `id` на інше, наприклад, `id=101`, для доступу до профілю іншого користувача.

2. **Відмінність від інших уразливостей контролю доступу**:

- **Тонка грань контролю доступу**: на відміну від загальних уразливостей контролю доступу, які часто реалізуються через
  ролі (наприклад, адміністратор проти звичайного користувача), IDOR зосереджується на доступі до конкретних об’єктів (
  даних) в межах однієї ролі.
- **Авторизація об'єкта**: для усунення IDOR необхідно перевіряти кожен запит, щоб підтвердити, що користувач має доступ
  до конкретного об’єкта, а не просто має загальний рівень доступу, як це реалізується для більшості уразливостей
  контролю доступу.

3. **Приклад POC**:
   Якщо на сайті `example.com` користувач має доступ до свого профілю за URL:
   і змінює параметр `id=100` на `id=101`, перевірка на стороні сервера повинна переконатися, що `id=101` дійсно
   належить поточному користувачеві, інакше це призведе до IDOR.

Для запобігання **IDOR** необхідно застосовувати точкову авторизацію для кожного об'єкта, що ускладнює реалізацію
порівняно з іншими механізмами контролю доступу, які працюють на рівні ролей або загальних прав.

## 11. Що таке JWKs і JKUs та як відрізняється їх використання в JWT

**JWKs (JSON Web Keys)** і **JKUs (JSON Key URLs)** — це способи обміну ключами для валідації цифрових підписів у
токенах **JWT (JSON Web Token)**.

1. **JWK (JSON Web Key)**: це формат для представлення криптографічних ключів в JSON, який включає параметри ключа (
   наприклад, `kty`, `use`, `kid`). JWK використовується для передачі ключів у безпечному форматі та дозволяє серверам
   перевіряти підписи JWT за допомогою конкретного ключа.

2. **JKU (JSON Key URL)**: це URL-адреса, яка вказує на місце розташування набору JWKs. Замість передачі ключів в самому
   токені JWT, JKU дає можливість отримати ключі з певного сервера, що зберігає їх у форматі JWK. Це дозволяє динамічно
   оновлювати ключі без зміни самого токена.

3. **Відмінності у використанні**:
    - **JWK** може використовуватись для безпосереднього включення ключів у токен для локальної валідації.
    - **JKU** надає URL для отримання публічних ключів зі стороннього сервера, що зручно для динамічної перевірки
      підписів без включення самих ключів у токен.

4. **Приклад використання JKU у JWT**:
   ```json
   {
     "alg": "RS256",
     "typ": "JWT",
     "jku": "https://example.com/keys"
   }

У цьому прикладі jku вказує на URL https://example.com/keys, де зберігається JWK, що дозволяє серверу завантажити ключ
для перевірки підпису JWT.

JWKs зберігають самі ключі, тоді як JKUs вказують на URL, з якого можна отримати ці ключі, що знижує ризики та спрощує
управління ключами.

## 12. Що таке бізнес-логіка та чим відрізняється тестування уразливостей бізнес-логіки від XSS, SQLi тощо

**Бізнес-логіка** в контексті веб-додатків — це правила і процедури, що визначають, як працює додаток відповідно до
своїх бізнес-цілей. Бізнес-логіка управляє тим, як обробляються дані, виконується логіка транзакцій, і що дозволено або
заборонено користувачам в додатку. Уразливості бізнес-логіки можуть призводити до порушення нормального функціонування
додатка, дозволяючи обхід бізнес-правил, що може вплинути на доходи або безпеку даних.

1. **Відмінності в тестуванні**:
    - **Вимоги до розуміння процесів**: на відміну від XSS або SQLi, які спрямовані на знайдення технічних проблем,
      тестування бізнес-логіки вимагає розуміння бізнес-процесів, логіки додатку і очікуваної поведінки користувачів.
    - **Індивідуальний підхід**: уразливості бізнес-логіки унікальні для кожного додатка і залежать від конкретних
      правил та сценаріїв використання. Це відрізняється від XSS або SQLi, де можна використовувати стандартні технічні
      інструменти і шаблони атак.
    - **Симуляція сценаріїв зловживань**: необхідно моделювати сценарії зловживань, такі як багаторазові запити, обхід
      обмежень доступу, або створення трансакцій, які суперечать логіці додатка.

2. **Приклад бізнес-логічної уразливості**:
    - При покупці товарів у кошику додаються знижки, які повинні бути обмежені до одного використання. Якщо користувач
      може багаторазово застосовувати знижку до одного товару, він зловживає уразливістю бізнес-логіки.

**Тестування уразливостей бізнес-логіки** вимагає детального розуміння функціоналу, специфічних для кожного додатка
правил і можливих способів зловживань, на відміну від технічних уразливостей, які можна виявити за допомогою загальних
інструментів.

## 13. Три пейлоади для виявлення серверного шаблонного рушія через повідомлення про помилку

1. **Python (Jinja2)**: використовується в багатьох фреймворках на Python.
    - **Пейлоад**: `{{ 7*'7' }}`
    - **Очікуваний результат**: якщо використовується Jinja2, сервер поверне повідомлення про помилку, оскільки рядок не
      можна помножити на число в Jinja2. Це дозволить зрозуміти, що використовується рушій на Python.

2. **PHP (Twig)**: часто застосовується з фреймворками на PHP.
    - **Пейлоад**: `{{ 7*7 }}`
    - **Очікуваний результат**: при використанні Twig ви отримаєте результат `49`, якщо відображення дозволено, або
      повідомлення про помилку, якщо помноження обробляється неправильно. Це може вказувати на те, що рушій Twig працює
      на сервері.

3. **JavaScript (Handlebars)**: популярний для серверного рендерингу в JavaScript-додатках.
    - **Пейлоад**: `{{#with 7}}`
    - **Очікуваний результат**: якщо сервер відповість помилкою або кодом, який показує обробку `#with`, це може
      свідчити про використання шаблонного рушія Handlebars.

**Ці пейлоади** генерують специфічні для рушіїв помилки, які дозволяють визначити використовуваний серверний шаблонний
рушій на основі отриманих відповідей.

АБО

- Неправильний синтаксис: ${{<%[%'"}}%\.
- Ділення на нуль: ${1/0}
- Неправильні імена змінних: ${test}

## 14. Яка мета заголовка Sec-WebSocket-Key?

**Sec-WebSocket-Key** — це заголовок, що використовується при встановленні з'єднання WebSocket для забезпечення безпеки
та перевірки зв'язку між клієнтом і сервером. Його мета — підтвердити, що запит на з'єднання є справжнім
WebSocket-запитом, а не випадковим HTTP-запитом.

1. **Принцип роботи**:
    - Клієнт відправляє заголовок `Sec-WebSocket-Key` із випадково згенерованим значенням, яке сервер використовує для
      створення відповідного заголовка `Sec-WebSocket-Accept`.
    - Сервер бере значення з `Sec-WebSocket-Key`, додає до нього фіксований
      GUID (`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`), хешує за допомогою SHA-1 та кодує в Base64.

2. **Призначення**:
    - Перешкоджати підробці WebSocket-запитів з використанням інших протоколів.
    - Впевнитися, що з'єднання є WebSocket-з'єднанням, і сервер готовий до встановлення такої комунікації.

   **Приклад**:

Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==

Сервер на основі цього значення поверне відповідний `Sec-WebSocket-Accept`, завершуючи процес рукопотискання WebSocket.

**Sec-WebSocket-Key** забезпечує механізм підтвердження автентичності WebSocket-з'єднання і запобігає атакам за
допомогою перехоплення HTTP-запитів.

## 15. Що дозволяє значення "unsafe-inline" у директиві script-src для CSP?

Значення **"unsafe-inline"** у директиві **script-src** для Content Security Policy (CSP) дозволяє виконання **
вбудованих скриптів** без окремих атрибутів безпеки, таких як `nonce` або `hash`. Це включає як скрипти, що
безпосередньо прописані у тегах `<script>`, так і обробники подій, написані безпосередньо в HTML.

1. **Мета і ризики**:
    - Використання `unsafe-inline` знижує рівень безпеки, дозволяючи потенційно шкідливий код, та робить додаток
      вразливим до **XSS-атак**.
    - `unsafe-inline` зазвичай не рекомендується для сучасних веб-додатків, оскільки він дозволяє виконання будь-яких
      вбудованих скриптів без перевірки.

2. **Приклад**:
   ```html
   Content-Security-Policy: script-src 'self' 'unsafe-inline';

## 16. Приклад безстанної автентифікації та її слабке місце

**Stateless Authentication** — це механізм автентифікації, при якому сервер не зберігає сесійних даних про користувача.
Замість цього автентифікація відбувається за допомогою токенів, які містять усю необхідну інформацію і передаються з
кожним запитом. Найпоширеніший приклад — це **JSON Web Token (JWT)**.

1. **Приклад JWT**:
    - Після автентифікації користувач отримує **JWT**, що включає інформацію про нього та підписаний сервером.
    - Кожен наступний запит включає цей токен, що дозволяє серверу перевірити користувача без збереження сесії.
    - Наприклад:
      ```http
      Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsInJvbGUiOiJ1c2VyIn0.s3cr3t
      ```

2. **Недолік**:
    - **Неможливість анулювати токен**: якщо токен був зкомпрометований або користувач вийшов із системи, сервер не має
      способу «забути» виданий токен, оскільки не зберігає його стан. Це може призвести до ситуацій, коли токен
      залишається дійсним до закінчення терміну дії (наприклад, через кілька годин), і зловмисник може ним скористатися.

**Stateless Authentication** зручна для масштабованості, але її слабкість полягає в неможливості швидко відкликати
доступ після втрати або компрометації токена.

## 17. Три способи зменшення ризику Cross-Site Request Forgery (CSRF)

1. **Використання CSRF-токенів**:
    - При кожній сесії генерується унікальний CSRF-токен, який включається у форму або запит для перевірки на стороні
      сервера. Цей токен додається в параметр запиту або заголовок.
    - Якщо токен відсутній або неправильний, сервер відхиляє запит.
    - **Приклад**: токен додається в приховане поле форми.
      ```html
      <input type="hidden" name="csrf_token" value="s3cur3tok3n">
      ```

2. **Перевірка заголовка Origin або Referer**:
    - Сервер перевіряє заголовок `Origin` або `Referer` у запиті. Запити, що надходять із іншого домену, відхиляються.
    - Це дозволяє переконатися, що запит походить із того ж домену, що й оброблюваний ресурс.
    - **Примітка**: цей метод може бути ненадійним, оскільки деякі браузери можуть не надсилати `Origin` або `Referer` у
      всіх запитах.

3. **Вимагати sстановлення SameSite в значення Lax або Strict**:
    - Встановлення атрибуту файлу cookie SameSite в значення Lax або Strict для сесійних файлів cookie може запобігти
      додаванню цього файлу cookie до міжсайтових запитів, що зробить підроблені запити неавтентифікованими. Існують
      деякі винятки, якщо використовується Lax.

## 18. Що таке параметрні сутності XML і які обмеження вони мають у XXE-ін'єкціях?

**XML параметрні сутності** — Посилання на об'єкти параметрів XML здійснюється за допомогою % замість &, але вони можуть
бути використані лише у DTD, а не в основному XML-документі. Це обмеження означає, що сутності параметрів часто корисні
лише для позасмугових методів XXE.

## 19. Рекомендації щодо усунення DOM-based XSS

1. **Уникайте небезпечних методів і функцій DOM**:
    - Уникайте використання функцій, таких як `innerHTML`, `document.write`, `eval`, `setTimeout`, `setInterval`,
      оскільки вони можуть виконувати введені користувачем дані без перевірки.
    - Замість `innerHTML` використовуйте `textContent` або `innerText`, якщо необхідно лише відобразити текст.

2. **Виконуйте екранування та перевірку даних перед використанням**:
    - Якщо необхідно вивести дані користувача у DOM, застосовуйте екранування символів. Наприклад, для HTML
      використовуйте функцію, яка замінює `<`, `>`, `&`, `"` на відповідні HTML-ентіті (`&lt;`, `&gt;`, `&amp;`
      , `&quot;`).
    - Виконуйте валідацію введених даних (наприклад, перевіряйте, що введені URL-адреси є коректними, якщо це потрібно
      для навігації).

3. **Використовуйте безпечні API для маніпуляції DOM**:
    - Для динамічного додавання контенту використовуйте безпечні API, такі як `createElement` та `appendChild`, що
      дозволяє уникнути прямої вставки HTML.
    - Наприклад:
      ```javascript
      const newDiv = document.createElement("div");
      newDiv.textContent = userInput;
      document.body.appendChild(newDiv);
      ```

4. **Застосовуйте Content Security Policy (CSP)**:
    - Використовуйте **CSP**, щоб обмежити виконання скриптів з неперевірених джерел. Додаткові обмеження, такі як
      заборона `unsafe-inline`, можуть значно знизити ризик DOM-based XSS.

5. **Навчайте розробників**:
    - Залучайте розробників до навчання з веб-безпеки, щоб вони розуміли, як запобігти DOM-based XSS і безпечно
      працювати з JavaScript та DOM.

**Виконання цих рекомендацій допоможе мінімізувати ризик DOM-based XSS**, забезпечивши надійне оброблення і відображення
введених користувачем даних у веб-додатках.

## 20. Умови, необхідні для запобігання відправки CORS Preflight-запиту браузером

CORS (Cross-Origin Resource Sharing) **Preflight-запит** відправляється браузером, коли запит відрізняється від "
простого" (simple) запиту, щоб отримати дозвіл з сервера на обробку ресурсу з іншого домену. Щоб уникнути
Preflight-запиту, запит повинен відповідати наступним умовам:

1. Дозволені тільки методи GET, HEAD або POST.
2. Вручну можна встановити лише наступні заголовки: Accept, Accept-Language, Content-Language, Content-Type, Range.
3. Якщо задано Content-Type, він повинен використовувати одне з наступних значень: application/x-www-form-urlencoded,
   multipart/form-data, text/plain.
4. Якщо використовувався XMLHttpRequest, у властивості XMLHttpRequest.upload не повинно бути зареєстровано жодного
   слухача подій.
5. Не використовувався об'єкт ReadableStream.

## 21. Три способи експлуатації уразливості небезпечної десеріалізації

1. Зміна значення атрибута об'єкта.
2. Зміна типу атрибуту об'єкта.
3. Використання магічного методу для виклику інших функцій/методів (потенційно може призвести до RCE).

## 22. Перелічіть перевірки, які може виконувати програма, щоб переконатися, що файли не можуть містити шкідливого вмісту і можуть бути завантажені лише до певних каталогів.

1. Дозволяє завантажувати файли лише з певними розширеннями та mime-типами.
2. Виконання аналізу файлів (для підтвердження типу файлу) та антивірусного сканування.
3. Виконання канонізації шляху перед перевіркою відповідності кінцевого розташування файлу дозволеному каталогу.

## 23. Як працює Mass Assignment і які наслідки експлуатації цієї уразливості?

**Mass Assignment** — це уразливість, що виникає, коли веб-додаток автоматично прив’язує вхідні дані користувача до
внутрішніх об'єктів або моделей без належної перевірки. Це дозволяє змінювати атрибути, які не повинні бути доступні
користувачу.

1. **Як це працює**:
    - Багато фреймворків (наприклад, Laravel, Ruby on Rails) підтримують функцію "масового присвоєння" (
      `mass assignment`), що дозволяє оновлювати всі атрибути моделі одразу, приймаючи вхідні дані від користувача.
    - Якщо контролер дозволяє змінювати всі передані параметри без обмежень, зловмисник може змінити критично важливі
      поля, наприклад, роль (`role=admin`) або баланс (`balance=99999`).

2. **Приклад експлуатації**:
    - Припустимо, є форма оновлення профілю:
      ```html
      <form action="/update-profile" method="POST">
        <input type="text" name="username" value="user123">
        <input type="text" name="email" value="user@example.com">
        <input type="submit" value="Save">
      </form>
      ```
    - Якщо бекенд приймає всі вхідні параметри без фільтрації, атакуючий може відправити додатковий параметр через
      `cURL` або в JavaScript-консолі:
      ```json
      {
        "username": "hacker",
        "role": "admin"
      }
      ```
    - Якщо сервер не перевіряє дозволені поля, обліковий запис користувача може отримати статус "адміністратор".

3. **Можливі наслідки**:
    - **Підвищення привілеїв** (наприклад, зміна `role=user` на `role=admin`).
    - **Фінансові маніпуляції** (наприклад, зміна балансу, цін товарів, знижок).
    - **Отримання доступу до прихованих функцій** (наприклад, зміна `is_active=false` на `is_active=true` для обходу
      блокування облікового запису).

### Як запобігти?

- Використовуйте "whitelisting" полів (`fillable` у Laravel або `strong parameters` у Rails).
- Забороняйте зміну критичних параметрів напряму.
- Використовуйте окремі API-ендпоїнти для адміністративних дій.

## 24. Що таке GraphQL Batching і як його можна використати для обходу rate limiting?

Масове призначення відбувається, коли функціонал, що дозволяє користувачам створювати або оновлювати «об'єкти», не
обмежує, які атрибути користувач може вказати. Це частіше зустрічається в сучасних фреймворках типу MVC.

Це може призвести до того, що зловмисники зможуть «підвищити» свою роль (наприклад, до адміністратора), додати гроші на
баланс облікового запису, призначити потенційно негативні ресурси іншим користувачам або здійснити атаку з підробкою
журналів шляхом зміни значень дат, а також незліченну кількість інших атак.

## 25. Що таке жонглювання типами і чому формат JSON допомагає використовувати ці уразливості?

Жонглювання типами - це особливість деяких мов програмування, коли при виконанні певних операцій змінні
конвертуються в інший тип (наприклад, рядковий, цілий, логічний), а не генерують виключення. Наприклад, при
конкатенації рядка з цілим числом, ціле число буде перетворено в рядок.

Однак це може призвести до вразливостей, коли збереження типу є важливим. Формат JSON допомагає використовувати ці
вразливості, оскільки він підтримує широкий спектр типів даних (числа, рядки, булеві, масиви, об'єкти та нулі), тоді як
звичайні параметри URL/тіла часто підтримують лише рядки та масиви.

## 26. Опишіть 3 методи, які ви можете використовувати для пошуку конфіденційних даних, що розкриваються додатком.

Source code analysis.
Directory busting.
Causing errors / exceptions / stack traces by fuzzing.
Access control exploitation.
Google dorking.
Git repo history analysis.
Exploiting SQL injections

## 27. Describe the attributes of a request which make it effectively immune to CSRF (i.e. CSRF mitigation is not required).
Знову ж таки, тут є кілька можливих відповідей:
Якщо для автентифікації використовується заголовок Authorization і нетривіальний токен (тобто не Basic Auth), наприклад, JWT, або будь-який інший кастомний заголовок з непередбачуваним значенням.
Якщо сервер не підтримує CORS або має політику блокування, і використовується нестандартний HTTP-метод (наприклад, PUT, DELETE), або тіло запиту використовує JSON/XML і вимагає відповідного Content-Type.
Якщо запит покладається на «секретне» значення, яке фактично стає анти-CSRF токеном. Наприклад, запити на вхід в систему несприйнятливі до CSRF, тому що якщо зловмисник знає облікові дані жертви, йому навіть не потрібно виконувати CSRF-атаку*.
*Існують рідкісні граничні випадки, коли виконання CSRF-атаки на логін, незважаючи на знання облікових даних жертви, може бути корисним.